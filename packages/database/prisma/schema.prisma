generator client {
  provider   = "prisma-client"
  output     = "../generated/prisma"
  engineType = "client"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

// Auth models
// ------------------------------------------------------------
model User {
  id            String    @id
  name          String
  email         String
  emailVerified Boolean   @default(false)
  image         String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @default(now()) @updatedAt
  sessions      Session[]
  accounts      Account[]
  person        Person?

  @@unique([email])
  @@index([email])
  @@map("user")
}

model Session {
  id        String   @id
  expiresAt DateTime
  token     String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  ipAddress String?
  userAgent String?
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([token])
  @@index([token, userId])
  @@map("session")
}

model Account {
  id                    String    @id
  accountId             String
  providerId            String
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  @@index([userId])
  @@map("account")
}

model Verification {
  id         String   @id
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @default(now()) @updatedAt

  @@index([identifier])
  @@map("verification")
}

// ------------------------------------------------------------
// Business-logic models
// 4 enums
// 7 models (3 core and 4 supporting)

enum RfqStatus {
  SENT
  RECEIVED
}

enum QuoteOutcome {
  WON
  PENDING
  LOST
}

enum CompanyType {
  SUPPLIER
  CLIENT
  CONTRACTOR
  CONSULTANT
}

enum Currency {
  EGP
  USD
  EUR
  GBP
  SAR
  AED
}

enum ProjectStatus {
  IN_HAND
  TENDER
}

model Quote {
  id                          String       @id @default(uuid())
  // ARGO-Q-2xxx-mm-yyyy
  serialNumber                Int          @default(autoincrement())
  referenceNumber             String
  date                        DateTime
  currency                    Currency
  rate                        Float
  value                       Int
  notes                       String?
  authorId                    String
  author                      Person       @relation("Author", fields: [authorId], references: [id], onDelete: Cascade)
  supplierId                  String?
  supplier                    Company?     @relation("SupplierCompany", fields: [supplierId], references: [id], onDelete: Cascade)
  clientId                    String
  client                      Company      @relation("ClientCompany", fields: [clientId], references: [id], onDelete: Cascade)
  projectId                   String
  project                     Project      @relation(fields: [projectId], references: [id], onDelete: Cascade)
  contactPersonId             String
  contactPerson               Person       @relation("ContactPerson", fields: [contactPersonId], references: [id], onDelete: Cascade)
  salesPersonId               String?
  salesPerson                 Person?      @relation("SalesPerson", fields: [salesPersonId], references: [id], onDelete: Cascade)
  quoteOutcome                QuoteOutcome @default(PENDING)
  approximateSiteDeliveryDate DateTime?
  createdAt                   DateTime     @default(now())
  updatedAt                   DateTime     @updatedAt
  Rfq                         Rfq[]
  FollowUp                    FollowUp[]
  objectKeys                  String[]

  // --- INDEXES ---
  @@index([authorId])
  @@index([supplierId])
  @@index([clientId])
  @@index([projectId])
  @@index([contactPersonId])
  @@index([quoteOutcome]) // Vital for dashboard stats (Won vs Lost)
  @@index([referenceNumber]) // Vital for search
  @@index([date]) // Vital for sorting/filtering by year/month
}

model FollowUp {
  id        String   @id @default(uuid())
  quoteId   String
  quote     Quote    @relation(fields: [quoteId], references: [id], onDelete: Cascade)
  authorId  String
  author    Person   @relation(fields: [authorId], references: [id], onDelete: Cascade)
  notes     String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([quoteId])
  @@index([authorId])
}

model Rfq {
  id              String    @id @default(uuid())
  // ARGO-RFQ-1xxx-mm-yyyy
  serialNumber    Int       @default(autoincrement())
  referenceNumber String
  date            DateTime?
  currency        Currency
  rate            Float
  value           Int
  notes           String?
  authorId        String
  author          Person    @relation(fields: [authorId], references: [id], onDelete: Cascade)
  supplierId      String
  supplier        Company   @relation("SupplierCompany", fields: [supplierId], references: [id], onDelete: Cascade)
  clientId        String
  client          Company   @relation("ClientCompany", fields: [clientId], references: [id], onDelete: Cascade)
  projectId       String
  project         Project   @relation(fields: [projectId], references: [id], onDelete: Cascade)
  // once recieved new fields will unlock for value, currency, rate
  rfqReceivedAt   DateTime?
  quoteId         String?
  quote           Quote?    @relation(fields: [quoteId], references: [id])
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  rfqStatus       RfqStatus @default(SENT)

  // --- INDEXES ---
  @@index([authorId])
  @@index([supplierId])
  @@index([clientId])
  @@index([projectId])
  @@index([referenceNumber]) // Search
}

// is quotation followed up or not
enum RegistrationStatus {
  PURSUING
  REQUIREMENTS_COLLECTED
  DOCS_SENT
  UNDER_REVIEW
  PENDING_CONFIRMATION
  VERIFIED
  ON_HOLD
  DECLINED
}

model Registration {
  id                 String             @id @default(uuid())
  companyId          String
  company            Company            @relation(fields: [companyId], references: [id], onDelete: Cascade)
  registrationStatus RegistrationStatus
  authorId           String
  author             Person             @relation(fields: [authorId], references: [id], onDelete: Cascade)
  registrationFile   String?
  notes              String?
  createdAt          DateTime           @default(now())
  updatedAt          DateTime           @updatedAt

  // --- INDEXES ---
  @@index([companyId])
  @@index([authorId])
  @@index([registrationStatus]) // For filtering active registrations
}

// suppliers registered`
// add in the company model

enum PersonType {
  AUTHOR
  CONTACT_PERSON
  INTERNAL
}

model Person {
  id                      String         @id @default(uuid())
  name                    String?
  firstName               String?
  lastName                String?
  title                   String?
  email                   String?
  phone                   String?
  // Internal sales person creating quotes
  authoredQuotes          Quote[]        @relation("Author")
  // External contact person for quotes
  contactForQuotes        Quote[]        @relation("ContactPerson")
  salesPersonQuotes       Quote[]        @relation("SalesPerson")
  authoredRfqs            Rfq[]
  companyId               String?
  company                 Company?       @relation(fields: [companyId], references: [id], onDelete: Cascade)
  type                    PersonType     @default(INTERNAL)
  userId                  String?        @unique
  user                    User?          @relation(fields: [userId], references: [id])
  createdAt               DateTime       @default(now())
  updatedAt               DateTime       @updatedAt
  Registration            Registration[]
  FollowUp                FollowUp[]
  companiesResponsibleFor Company[]      @relation("ResponsibleSalesPerson")

  // --- INDEXES ---
  @@index([companyId])
  @@index([name]) // For search/autocomplete
  @@index([email]) // For search
}

model Company {
  id                       String         @id @default(uuid())
  name                     String         @unique
  email                    String?
  phone                    String?
  type                     CompanyType    @default(CLIENT)
  projects                 Project[]
  clientQuotes             Quote[]        @relation("ClientCompany")
  supplierQuotes           Quote[]        @relation("SupplierCompany")
  clientRFQs               Rfq[]          @relation("ClientCompany")
  supplierRFQs             Rfq[]          @relation("SupplierCompany")
  people                   Person[]
  createdAt                DateTime       @default(now())
  updatedAt                DateTime       @updatedAt
  responsibleSalesPerson   Person?        @relation("ResponsibleSalesPerson", fields: [responsibleSalesPersonId], references: [id])
  responsibleSalesPersonId String?
  Registration             Registration[]

  // --- INDEXES ---
  @@index([responsibleSalesPersonId])
  @@index([name]) // Vital for company lookups/search
  @@index([type]) // To quickly separate Clients from Suppliers
}

// one project could have many quotes and many companies actually
// also one project could have many suppliers and many clients
model Project {
  id        String         @id @default(uuid())
  name      String
  status    ProjectStatus?
  companyId String?
  // a project could share many companies and the company-project is determined by the quote and not this redundant relationship
  // client company
  company   Company?       @relation(fields: [companyId], references: [id])
  quotes    Quote[]
  rfqs      Rfq[]
  createdAt DateTime       @default(now())
  updatedAt DateTime       @updatedAt

  // --- INDEXES ---
  @@index([companyId])
  @@index([name])
}

// Capacity feature to associate products with quotes.
// many-to-many 
// product table
// type: pumps
// capacity

// total quoted value
// totalt lost 
// total won
// convesion rate based on finalized (hit rate): total won / total won + total lost
// potential revenue
// total quoted - total lost = potential revenue to be gained (will still be converted)

// Documents for reference (all pdfs)
// authorization letters
// authorization certificates, company trade licences, company tax card, company profile, catalogs.
